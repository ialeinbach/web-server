#!/bin/bash

NGINX_CONF_DIR=etc/nginx/include

SERVER_NAME_CONF=$NGINX_CONF_DIR/server_name.conf
SSL_CONF=$NGINX_CONF_DIR/ssl.conf

SSL_DIR=etc/ssl


function usage() {
	echo ".-------."
	echo "| Usage |"
	echo "'-------'"
	echo
	echo "./wizard.sh [OPTIONS] MODE NAME"
	echo
	echo ".-------."
	echo "| Modes |"
	echo "'-------'"
	echo
	echo "probe    spin up and open bash prompt into container"
	echo "serve    spin up and start serving with container"
	echo
	echo ".---------."
	echo "| Options |"
	echo "'---------'"
	echo
	echo "-h       print this help message"
	echo "-f       print out logs once container is running"
	echo "-c       SSL certificate"
	echo "-k       SSL certificate key"
	echo "-p       SSL password file"
	echo "-n       don't tamper with config files"
}

function wizard() {
	local follow
	local cert key pass
	local no_config

	while getopts "hfc:k:p:n" opt; do
		case $opt in
			h) usage; exit 0  ;;
			f) follow=1       ;;
			c) cert="$OPTARG" ;;
			k) key="$OPTARG"  ;;
			p) pass="$OPTARG" ;;
			n) no_config=1    ;;
			*) usage; exit 1  ;;
		esac
	done

	shift $(( $OPTIND - 1 ))

	# MODE and NAME are required, so fail if they're missing.
	if [[ $# -lt 2 ]]; then
		echo "wizard: MODE and NAME required"
		usage
		exit 1
	fi

	local mode="$1"
	local name="$2"

	# Before touching anything, make sure we're not about to step on anyone
	# else's toes.
	case "$mode" in
		serve|probe)
			task "Checking for name collisions" \
				check_names "$name"             ;
		;;
	esac

	# If -n flag is provided, leave the config files alone.
	if [[ $no_config -ne 1 ]]; then
		case "$mode" in
			serve|probe)
				task "Configuring server name" \
					config_server_name "$name" ;

				task "Configuring SSL"                \
					config_ssl "$cert" "$key" "$pass" ;
			;;
		esac
	fi

	# Dispatch to the mode functions.
	case "$mode" in
		serve) mode_serve "$name" ;;
		probe) mode_probe "$name" ;;
		clean) mode_clean "$name" ;;
		*)
			panic "unrecognized mode: $mode"
		;;
	esac

	# If -f flag is provided, print out logs as they're generated.
	[[ $follow -eq 1 ]] && sudo docker logs --follow "$name"

	exit 0
}

#
# Mode Functions
#

function mode_serve() {
	local name="$1"

	task "Building image"        \
		sudo docker image build  \
			--tag "$name":latest \
			.                    ;

	task "Creating log volume" sudo docker volume create "$name"

	task "Creating container"                           \
		sudo docker container create                    \
			--name "$name"                              \
			--publish 80:80                             \
			--publish 443:443                           \
			--mount source="$name",destination=/var/log \
			"$name":latest                              ;

	task "Starting up container" sudo docker container start "$name"
}

function mode_probe() {
	local name="$1"

	task "Building image"        \
		sudo docker image build  \
			--tag "$name":latest \
			.                    ;

	task "Creating log volume" sudo docker volume create "$name"

	task "Creating and entering container"              \
		sudo docker container run                       \
			--name "$name"                              \
			--publish 80:80                             \
			--publish 443:443                           \
			--interactive --tty                         \
			--entrypoint /bin/bash                      \
			--mount source="$name",destination=/var/log \
			"$name":latest                              ;
}

#
# Config Functions
#

function config_ssl() {
	local cert="$1"
	local key="$2"
	local pass="$3"

	[[ -z "$cert" && -z "$key" ]] && return 0

	check_dirs "$SSL_DIR"
	check_dirs "$NGINX_CONF_DIR"

	check_files "$SSL_CONF" || return 1

	if [[ -n "$cert" ]]; then
		echo -n "Importing SSL certificate ... "
		cp "$cert" "$SSL_DIR"
		if [[ $? -eq 0 ]]; then
			echo "OK"
		else
			echo "ABORT"
			exit 1
		fi
	fi

	if [[ -n "$key" ]]; then
		echo -n "Importing SSL key ... "
		cp "$key" "$SSL_DIR"
		if [[ $? -eq 0 ]]; then
			echo "OK"
		else
			echo "ABORT"
			exit 1
		fi
	fi

	if [[ -n "$pass" ]]; then
		echo -n "Importing SSL password file ... "
		cp "$pass" "$SSL_DIR"
		if [[ $? -eq 0 ]]; then
			echo "OK"
		else
			echo "ABORT"
			exit 1
		fi
	fi

	echo -e "# Generated by wizard.sh!\n" > $SSL_CONF
	[[ -n "$cert" ]] && echo "ssl_certificate     $cert;" >> $SSL_CONF
	[[ -n "$key"  ]] && echo "ssl_certificate_key $key;"  >> $SSL_CONF
	[[ -n "$pass" ]] && echo "ssl_password_file   $pass;" >> $SSL_CONF
}

function config_server_name() {
	local name="$1"

	check_dirs "$NGINX_CONF_DIR"

	check_files "$SERVER_NAME_CONF" || return 1

	echo -e "# Generated by wizard.sh!\n" > $SERVER_NAME_CONF
	echo "server_name $name;" >> $SERVER_NAME_CONF
}

#
# Helper Functions
#

# A task corresponds to a printed-to-stdout point of progress of the script.
# It prints an associated message, then invokes the subsequently provided
# command, and reports success or failure.
function task() {
	local msg="$1"
	shift

	echo "$msg ..."
	eval "$@"

	if [[ $? -ne 0 ]]; then
		echo -e "ABORT\n"
		exit 1
	else
		echo -e "OK\n"
	fi
}

function panic() {
	echo "wizard:" "$@"
	exit 1
}

function confirm() {
	local -l response
	echo "$* [Y/n]"
	read -r response
	[[ ! "$response" =~ ^(n|no)$ ]]
}

# Look for name collisions with preexisting containers, volumes, and images.
function check_names() {
	local name="$1"

	local container="$(             \
		sudo docker container ls -a \
		| tail -n +2                \
		| awk '{print $2}'          \
		| grep "$name"              \
	)"                              ;

	local image="$(          \
		sudo docker image ls \
		| tail -n +2         \
		| awk '{print $1}'   \
		| grep "$name"       \
	)"                       ;

	local volume="$(          \
		sudo docker volume ls \
		| tail -n +2          \
		| awk '{print $2}'    \
		| grep "$name"        \
	)"                        ;

	local exitcode=0

	if [[ -n "$container" ]]; then
		exitcode=1
		echo "Container Name Collisions:"
		echo -e "$container\n"
	fi

	if [[ -n "$image" ]]; then
		exitcode=1
		echo "Image Name Collisions:"
		echo -e "$image\n"
	fi

	if [[ -n "$volume" ]]; then
		exitcode=1
		echo "Volume Name Collisions:"
		echo -e "$volume\n"
	fi

	if [[ $exitcode -ne 0 ]]; then
		confirm "Continue anyway?" && exitcode=0
	fi

	return $exitcode
}

# Make sure directories exist.
function check_dirs() {
	for path in "$@"; do
		[[ -d "$path" ]] || mkdir -p "$path"
	done
}

# Warn about any files that will be overwritten before doing so.
function check_files() {
	local -a preexisting

	for path in "$@"; do
		if [[ -f "$path" ]]; then
			preexisting+=("$path")
		else
			touch "$path"
		fi
	done

	[[ ${#preexisting[@]} -eq 0 ]] && return 0

	echo "Will be overwritten:"
	for file in $preexisting; do
		echo " -> $file"
	done
	echo

	confirm "Continue anyway?"
}

wizard "$@"
